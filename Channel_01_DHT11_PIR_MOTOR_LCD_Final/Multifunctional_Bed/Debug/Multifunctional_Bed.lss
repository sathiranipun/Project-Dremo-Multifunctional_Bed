
Multifunctional_Bed.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006ca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a8  00800060  000006ca  0000075e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  00800108  00800108  00000806  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000806  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000838  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  00000874  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001868  00000000  00000000  0000097c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000994  00000000  00000000  000021e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bd2  00000000  00000000  00002b78  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000218  00000000  00000000  0000374c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000538  00000000  00000000  00003964  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e1c  00000000  00000000  00003e9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  00004cb8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea ec       	ldi	r30, 0xCA	; 202
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 30       	cpi	r26, 0x08	; 8
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	a8 e0       	ldi	r26, 0x08	; 8
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 30       	cpi	r26, 0x0F	; 15
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 87 01 	call	0x30e	; 0x30e <main>
  8a:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <i2c_start>:
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );

}/* i2c_rep_start */
  92:	94 ea       	ldi	r25, 0xA4	; 164
  94:	96 bf       	out	0x36, r25	; 54
  96:	06 b6       	in	r0, 0x36	; 54
  98:	07 fe       	sbrs	r0, 7
  9a:	fd cf       	rjmp	.-6      	; 0x96 <i2c_start+0x4>
  9c:	91 b1       	in	r25, 0x01	; 1
  9e:	98 7f       	andi	r25, 0xF8	; 248
  a0:	98 30       	cpi	r25, 0x08	; 8
  a2:	11 f0       	breq	.+4      	; 0xa8 <i2c_start+0x16>
  a4:	90 31       	cpi	r25, 0x10	; 16
  a6:	79 f4       	brne	.+30     	; 0xc6 <i2c_start+0x34>
  a8:	83 b9       	out	0x03, r24	; 3
  aa:	84 e8       	ldi	r24, 0x84	; 132
  ac:	86 bf       	out	0x36, r24	; 54
  ae:	06 b6       	in	r0, 0x36	; 54
  b0:	07 fe       	sbrs	r0, 7
  b2:	fd cf       	rjmp	.-6      	; 0xae <i2c_start+0x1c>
  b4:	91 b1       	in	r25, 0x01	; 1
  b6:	98 7f       	andi	r25, 0xF8	; 248
  b8:	98 31       	cpi	r25, 0x18	; 24
  ba:	39 f0       	breq	.+14     	; 0xca <i2c_start+0x38>
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	90 34       	cpi	r25, 0x40	; 64
  c0:	29 f4       	brne	.+10     	; 0xcc <i2c_start+0x3a>
  c2:	80 e0       	ldi	r24, 0x00	; 0
  c4:	08 95       	ret
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	08 95       	ret
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	08 95       	ret

000000ce <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
  ce:	84 e9       	ldi	r24, 0x94	; 148
  d0:	86 bf       	out	0x36, r24	; 54
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
  d2:	06 b6       	in	r0, 0x36	; 54
  d4:	04 fc       	sbrc	r0, 4
  d6:	fd cf       	rjmp	.-6      	; 0xd2 <i2c_stop+0x4>

}/* i2c_stop */
  d8:	08 95       	ret

000000da <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
  da:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT) | (1<<TWEN);
  dc:	84 e8       	ldi	r24, 0x84	; 132
  de:	86 bf       	out	0x36, r24	; 54

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
  e0:	06 b6       	in	r0, 0x36	; 54
  e2:	07 fe       	sbrs	r0, 7
  e4:	fd cf       	rjmp	.-6      	; 0xe0 <i2c_write+0x6>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
  e6:	91 b1       	in	r25, 0x01	; 1
  e8:	98 7f       	andi	r25, 0xF8	; 248
  ea:	81 e0       	ldi	r24, 0x01	; 1
  ec:	98 32       	cpi	r25, 0x28	; 40
  ee:	09 f4       	brne	.+2      	; 0xf2 <i2c_write+0x18>
  f0:	80 e0       	ldi	r24, 0x00	; 0
	if( twst != TW_MT_DATA_ACK) return 1;
	return 0;

}/* i2c_write */
  f2:	08 95       	ret

000000f4 <lcd_sendCommand>:
//=================================================================
// Turns OFF cursor
//=================================================================
void lcd_cursorOFF(void)	
{
	lcd_sendCommand(0x0C);
  f4:	cf 93       	push	r28
  f6:	df 93       	push	r29
  f8:	c8 2f       	mov	r28, r24
  fa:	8e e4       	ldi	r24, 0x4E	; 78
  fc:	0e 94 49 00 	call	0x92	; 0x92 <i2c_start>
 100:	dc 2f       	mov	r29, r28
 102:	d0 7f       	andi	r29, 0xF0	; 240
 104:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 108:	84 60       	ori	r24, 0x04	; 4
 10a:	8d 2b       	or	r24, r29
 10c:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 110:	89 ef       	ldi	r24, 0xF9	; 249
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	01 97       	sbiw	r24, 0x01	; 1
 116:	f1 f7       	brne	.-4      	; 0x114 <lcd_sendCommand+0x20>
 118:	00 c0       	rjmp	.+0      	; 0x11a <lcd_sendCommand+0x26>
 11a:	00 00       	nop
 11c:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 120:	8d 2b       	or	r24, r29
 122:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 126:	89 ef       	ldi	r24, 0xF9	; 249
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	01 97       	sbiw	r24, 0x01	; 1
 12c:	f1 f7       	brne	.-4      	; 0x12a <lcd_sendCommand+0x36>
 12e:	00 c0       	rjmp	.+0      	; 0x130 <lcd_sendCommand+0x3c>
 130:	00 00       	nop
 132:	90 e1       	ldi	r25, 0x10	; 16
 134:	c9 9f       	mul	r28, r25
 136:	e0 01       	movw	r28, r0
 138:	11 24       	eor	r1, r1
 13a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 13e:	84 60       	ori	r24, 0x04	; 4
 140:	8c 2b       	or	r24, r28
 142:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 146:	89 ef       	ldi	r24, 0xF9	; 249
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	01 97       	sbiw	r24, 0x01	; 1
 14c:	f1 f7       	brne	.-4      	; 0x14a <lcd_sendCommand+0x56>
 14e:	00 c0       	rjmp	.+0      	; 0x150 <lcd_sendCommand+0x5c>
 150:	00 00       	nop
 152:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 156:	8c 2b       	or	r24, r28
 158:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 15c:	89 ef       	ldi	r24, 0xF9	; 249
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	01 97       	sbiw	r24, 0x01	; 1
 162:	f1 f7       	brne	.-4      	; 0x160 <lcd_sendCommand+0x6c>
 164:	00 c0       	rjmp	.+0      	; 0x166 <lcd_sendCommand+0x72>
 166:	00 00       	nop
 168:	0e 94 67 00 	call	0xce	; 0xce <i2c_stop>
 16c:	df 91       	pop	r29
 16e:	cf 91       	pop	r28
 170:	08 95       	ret

00000172 <lcd_sendData>:
 172:	cf 93       	push	r28
 174:	c8 2f       	mov	r28, r24
 176:	8e e4       	ldi	r24, 0x4E	; 78
 178:	0e 94 49 00 	call	0x92	; 0x92 <i2c_start>
 17c:	c0 7f       	andi	r28, 0xF0	; 240
 17e:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 182:	84 60       	ori	r24, 0x04	; 4
 184:	8c 2b       	or	r24, r28
 186:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 18a:	89 ef       	ldi	r24, 0xF9	; 249
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	01 97       	sbiw	r24, 0x01	; 1
 190:	f1 f7       	brne	.-4      	; 0x18e <lcd_sendData+0x1c>
 192:	00 c0       	rjmp	.+0      	; 0x194 <lcd_sendData+0x22>
 194:	00 00       	nop
 196:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 19a:	8c 2b       	or	r24, r28
 19c:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 1a0:	89 ef       	ldi	r24, 0xF9	; 249
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	01 97       	sbiw	r24, 0x01	; 1
 1a6:	f1 f7       	brne	.-4      	; 0x1a4 <lcd_sendData+0x32>
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <lcd_sendData+0x38>
 1aa:	00 00       	nop
 1ac:	0e 94 67 00 	call	0xce	; 0xce <i2c_stop>
 1b0:	cf 91       	pop	r28
 1b2:	08 95       	ret

000001b4 <lcd_init>:
 1b4:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__data_end>
 1b8:	80 e3       	ldi	r24, 0x30	; 48
 1ba:	0e 94 b9 00 	call	0x172	; 0x172 <lcd_sendData>
 1be:	80 e3       	ldi	r24, 0x30	; 48
 1c0:	0e 94 b9 00 	call	0x172	; 0x172 <lcd_sendData>
 1c4:	80 e3       	ldi	r24, 0x30	; 48
 1c6:	0e 94 b9 00 	call	0x172	; 0x172 <lcd_sendData>
 1ca:	80 e2       	ldi	r24, 0x20	; 32
 1cc:	0e 94 b9 00 	call	0x172	; 0x172 <lcd_sendData>
 1d0:	87 e8       	ldi	r24, 0x87	; 135
 1d2:	93 e1       	ldi	r25, 0x13	; 19
 1d4:	01 97       	sbiw	r24, 0x01	; 1
 1d6:	f1 f7       	brne	.-4      	; 0x1d4 <lcd_init+0x20>
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <lcd_init+0x26>
 1da:	00 00       	nop
 1dc:	88 e2       	ldi	r24, 0x28	; 40
 1de:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 1e2:	8c e0       	ldi	r24, 0x0C	; 12
 1e4:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 1e8:	86 e0       	ldi	r24, 0x06	; 6
 1ea:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 1f4:	08 95       	ret

000001f6 <lcd_putc>:
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	c8 2f       	mov	r28, r24
 1fc:	8e e4       	ldi	r24, 0x4E	; 78
 1fe:	0e 94 49 00 	call	0x92	; 0x92 <i2c_start>
 202:	dc 2f       	mov	r29, r28
 204:	d0 7f       	andi	r29, 0xF0	; 240
 206:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 20a:	d8 2b       	or	r29, r24
 20c:	8d 2f       	mov	r24, r29
 20e:	85 60       	ori	r24, 0x05	; 5
 210:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 214:	da 7f       	andi	r29, 0xFA	; 250
 216:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 21a:	8d 2b       	or	r24, r29
 21c:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 220:	80 e1       	ldi	r24, 0x10	; 16
 222:	c8 9f       	mul	r28, r24
 224:	90 01       	movw	r18, r0
 226:	11 24       	eor	r1, r1
 228:	c0 91 08 01 	lds	r28, 0x0108	; 0x800108 <__data_end>
 22c:	c5 60       	ori	r28, 0x05	; 5
 22e:	c2 2b       	or	r28, r18
 230:	8c 2f       	mov	r24, r28
 232:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 236:	2c 2f       	mov	r18, r28
 238:	2a 7f       	andi	r18, 0xFA	; 250
 23a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <__data_end>
 23e:	82 2b       	or	r24, r18
 240:	0e 94 6d 00 	call	0xda	; 0xda <i2c_write>
 244:	0e 94 67 00 	call	0xce	; 0xce <i2c_stop>
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	08 95       	ret

0000024e <lcd_goto_xy>:
 24e:	62 30       	cpi	r22, 0x02	; 2
 250:	31 f0       	breq	.+12     	; 0x25e <lcd_goto_xy+0x10>
 252:	63 30       	cpi	r22, 0x03	; 3
 254:	31 f0       	breq	.+12     	; 0x262 <lcd_goto_xy+0x14>
 256:	61 30       	cpi	r22, 0x01	; 1
 258:	29 f4       	brne	.+10     	; 0x264 <lcd_goto_xy+0x16>
 25a:	80 5c       	subi	r24, 0xC0	; 192
 25c:	03 c0       	rjmp	.+6      	; 0x264 <lcd_goto_xy+0x16>
 25e:	8c 5e       	subi	r24, 0xEC	; 236
 260:	01 c0       	rjmp	.+2      	; 0x264 <lcd_goto_xy+0x16>
 262:	8c 5a       	subi	r24, 0xAC	; 172
 264:	80 68       	ori	r24, 0x80	; 128
 266:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 26a:	08 95       	ret

0000026c <lcd_clear>:
//=================================================================
// Clears LCD
//=================================================================
void lcd_clear(void)				
{
	lcd_sendCommand(1<<LCD_CLR);
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	0e 94 7a 00 	call	0xf4	; 0xf4 <lcd_sendCommand>
 272:	08 95       	ret

00000274 <lcd_puts>:
}
//=================================================================
// Outputs string to LCD
//=================================================================
void lcd_puts(char* data)	
{
 274:	1f 93       	push	r17
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
	register uint8_t i;

	// check to make sure we have a good pointer
	if (!data) return;
 27a:	00 97       	sbiw	r24, 0x00	; 0
 27c:	b1 f0       	breq	.+44     	; 0x2aa <lcd_puts+0x36>
 27e:	ec 01       	movw	r28, r24
 280:	10 e0       	ldi	r17, 0x00	; 0
 282:	07 c0       	rjmp	.+14     	; 0x292 <lcd_puts+0x1e>

	// print data
	for(i=0; i<(strlen(data)); i++)
	{
		lcd_putc(data[i]);
 284:	fe 01       	movw	r30, r28
 286:	e2 0f       	add	r30, r18
 288:	f3 1f       	adc	r31, r19
 28a:	80 81       	ld	r24, Z
 28c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <lcd_putc>

	// check to make sure we have a good pointer
	if (!data) return;

	// print data
	for(i=0; i<(strlen(data)); i++)
 290:	1f 5f       	subi	r17, 0xFF	; 255
 292:	21 2f       	mov	r18, r17
 294:	30 e0       	ldi	r19, 0x00	; 0
 296:	fe 01       	movw	r30, r28
 298:	01 90       	ld	r0, Z+
 29a:	00 20       	and	r0, r0
 29c:	e9 f7       	brne	.-6      	; 0x298 <lcd_puts+0x24>
 29e:	31 97       	sbiw	r30, 0x01	; 1
 2a0:	ec 1b       	sub	r30, r28
 2a2:	fd 0b       	sbc	r31, r29
 2a4:	2e 17       	cp	r18, r30
 2a6:	3f 07       	cpc	r19, r31
 2a8:	68 f3       	brcs	.-38     	; 0x284 <lcd_puts+0x10>
	{
		lcd_putc(data[i]);
	}
}
 2aa:	df 91       	pop	r29
 2ac:	cf 91       	pop	r28
 2ae:	1f 91       	pop	r17
 2b0:	08 95       	ret

000002b2 <Request>:

uint8_t c=0,I_RH,D_RH,I_Temp,D_Temp,CheckSum;

void Request()				// Microcontroller send start pulse/request 
{
	DDRD |= (1<<DHT11_PIN);
 2b2:	8d 9a       	sbi	0x11, 5	; 17
	PORTD &= ~(1<<DHT11_PIN);	
 2b4:	95 98       	cbi	0x12, 5	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2b6:	8f e9       	ldi	r24, 0x9F	; 159
 2b8:	9c e8       	ldi	r25, 0x8C	; 140
 2ba:	01 97       	sbiw	r24, 0x01	; 1
 2bc:	f1 f7       	brne	.-4      	; 0x2ba <Request+0x8>
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <Request+0xe>
 2c0:	00 00       	nop
	_delay_ms(18);	
	PORTD |= (1<<DHT11_PIN);	
 2c2:	95 9a       	sbi	0x12, 5	; 18
 2c4:	08 95       	ret

000002c6 <Response>:
	
}

void Response()				/* receive response from DHT11 */
{
	DDRD &= ~(1<<DHT11_PIN);
 2c6:	8d 98       	cbi	0x11, 5	; 17
	while(PIND & (1<<DHT11_PIN));
 2c8:	85 99       	sbic	0x10, 5	; 16
 2ca:	fe cf       	rjmp	.-4      	; 0x2c8 <Response+0x2>
	while((PIND & (1<<DHT11_PIN))==0);
 2cc:	85 9b       	sbis	0x10, 5	; 16
 2ce:	fe cf       	rjmp	.-4      	; 0x2cc <Response+0x6>
	while(PIND & (1<<DHT11_PIN));
 2d0:	85 99       	sbic	0x10, 5	; 16
 2d2:	fe cf       	rjmp	.-4      	; 0x2d0 <Response+0xa>
	
}
 2d4:	08 95       	ret

000002d6 <Receive_data>:

uint8_t Receive_data()			/* receive data */
{
 2d6:	88 e0       	ldi	r24, 0x08	; 8
 2d8:	90 e0       	ldi	r25, 0x00	; 0
	for (int q=0; q<8; q++)
	{
		while((PIND & (1<<DHT11_PIN)) == 0);  
 2da:	85 9b       	sbis	0x10, 5	; 16
 2dc:	fe cf       	rjmp	.-4      	; 0x2da <Receive_data+0x4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2de:	20 e5       	ldi	r18, 0x50	; 80
 2e0:	2a 95       	dec	r18
 2e2:	f1 f7       	brne	.-4      	; 0x2e0 <Receive_data+0xa>
		_delay_us(30);
		if(PIND & (1<<DHT11_PIN))
 2e4:	85 9b       	sbis	0x10, 5	; 16
 2e6:	07 c0       	rjmp	.+14     	; 0x2f6 <Receive_data+0x20>
		c = (c<<1)|(0x01);	
 2e8:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <c>
 2ec:	22 0f       	add	r18, r18
 2ee:	21 60       	ori	r18, 0x01	; 1
 2f0:	20 93 09 01 	sts	0x0109, r18	; 0x800109 <c>
 2f4:	05 c0       	rjmp	.+10     	; 0x300 <Receive_data+0x2a>
		else			
		c = (c<<1);
 2f6:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <c>
 2fa:	22 0f       	add	r18, r18
 2fc:	20 93 09 01 	sts	0x0109, r18	; 0x800109 <c>
		while(PIND & (1<<DHT11_PIN));
 300:	85 99       	sbic	0x10, 5	; 16
 302:	fe cf       	rjmp	.-4      	; 0x300 <Receive_data+0x2a>
 304:	01 97       	sbiw	r24, 0x01	; 1
	
}

uint8_t Receive_data()			/* receive data */
{
	for (int q=0; q<8; q++)
 306:	49 f7       	brne	.-46     	; 0x2da <Receive_data+0x4>
		else			
		c = (c<<1);
		while(PIND & (1<<DHT11_PIN));
	}
	return c;
}
 308:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <c>
 30c:	08 95       	ret

0000030e <main>:

/////////////////////////////////////////// Initiating Phase ////////////////////////////////////////////////////////////////////

int main(void)
{
 30e:	cf 93       	push	r28
 310:	df 93       	push	r29
 312:	00 d0       	rcall	.+0      	; 0x314 <main+0x6>
 314:	00 d0       	rcall	.+0      	; 0x316 <main+0x8>
 316:	1f 92       	push	r1
 318:	cd b7       	in	r28, 0x3d	; 61
 31a:	de b7       	in	r29, 0x3e	; 62
	
	//////////////////////////// SET Data Pin Direction ////////////////////////////////////////////////////////////////
	DDRA &= ~(1<<PINA0);
 31c:	d0 98       	cbi	0x1a, 0	; 26
	DDRB = 0xFF;
 31e:	8f ef       	ldi	r24, 0xFF	; 255
 320:	87 bb       	out	0x17, r24	; 23
	//DDRB |= 1<<PINB0 | 1<<PINB1 | 1<<PINB2 | 1<<PINB3 | 1<<PINB4 ;
	DDRC |= 1 <<PINC6;
 322:	a6 9a       	sbi	0x14, 6	; 20
	DDRC |= 1<<PINC7;
 324:	a7 9a       	sbi	0x14, 7	; 20
	DDRD &= ~(1<<PIND0) &~(1<<PIND1) &~(1<<PIND2) &~(1<<PIND3) &~(1<<PIND4) &~(1<<PIND6);
 326:	81 b3       	in	r24, 0x11	; 17
 328:	80 7a       	andi	r24, 0xA0	; 160
 32a:	81 bb       	out	0x11, r24	; 17
	DDRD |= 1<<PIND7;
 32c:	8f 9a       	sbi	0x11, 7	; 17
	
	char data[5];
	lcd_init(LCD_BACKLIGHT_ON);			// Initialize LCD 
 32e:	88 e0       	ldi	r24, 0x08	; 8
 330:	0e 94 da 00 	call	0x1b4	; 0x1b4 <lcd_init>
	lcd_clear();			// Clear LCD 
 334:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
	lcd_goto_xy(2,0);		// column and row position 
 338:	60 e0       	ldi	r22, 0x00	; 0
 33a:	82 e0       	ldi	r24, 0x02	; 2
 33c:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
	lcd_puts(" MULTIFUNCTIONAL");
 340:	80 e6       	ldi	r24, 0x60	; 96
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
	lcd_goto_xy(0,1);
 348:	61 e0       	ldi	r22, 0x01	; 1
 34a:	80 e0       	ldi	r24, 0x00	; 0
 34c:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
	lcd_puts("    <<< BED >>>");
 350:	81 e7       	ldi	r24, 0x71	; 113
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 358:	2f ef       	ldi	r18, 0xFF	; 255
 35a:	3d e3       	ldi	r19, 0x3D	; 61
 35c:	49 e4       	ldi	r20, 0x49	; 73
 35e:	21 50       	subi	r18, 0x01	; 1
 360:	30 40       	sbci	r19, 0x00	; 0
 362:	40 40       	sbci	r20, 0x00	; 0
 364:	e1 f7       	brne	.-8      	; 0x35e <main+0x50>
 366:	00 c0       	rjmp	.+0      	; 0x368 <main+0x5a>
 368:	00 00       	nop
	_delay_ms(3000);
	lcd_clear();			
 36a:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
	lcd_goto_xy(2,0);		
 36e:	60 e0       	ldi	r22, 0x00	; 0
 370:	82 e0       	ldi	r24, 0x02	; 2
 372:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
	lcd_puts("       IT GROUP 01");
 376:	81 e8       	ldi	r24, 0x81	; 129
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
 37e:	8f ef       	ldi	r24, 0xFF	; 255
 380:	91 e1       	ldi	r25, 0x11	; 17
 382:	2a e7       	ldi	r18, 0x7A	; 122
 384:	81 50       	subi	r24, 0x01	; 1
 386:	90 40       	sbci	r25, 0x00	; 0
 388:	20 40       	sbci	r18, 0x00	; 0
 38a:	e1 f7       	brne	.-8      	; 0x384 <main+0x76>
 38c:	00 c0       	rjmp	.+0      	; 0x38e <main+0x80>
 38e:	00 00       	nop
	_delay_ms(5000);
	lcd_clear();
 390:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
 394:	3f ef       	ldi	r19, 0xFF	; 255
 396:	49 e6       	ldi	r20, 0x69	; 105
 398:	88 e1       	ldi	r24, 0x18	; 24
 39a:	31 50       	subi	r19, 0x01	; 1
 39c:	40 40       	sbci	r20, 0x00	; 0
 39e:	80 40       	sbci	r24, 0x00	; 0
 3a0:	e1 f7       	brne	.-8      	; 0x39a <main+0x8c>
 3a2:	00 c0       	rjmp	.+0      	; 0x3a4 <main+0x96>
 3a4:	00 00       	nop
	_delay_ms(1000);
	lcd_puts("Initiating...");
 3a6:	84 e9       	ldi	r24, 0x94	; 148
 3a8:	90 e0       	ldi	r25, 0x00	; 0
 3aa:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
 3ae:	9f ef       	ldi	r25, 0xFF	; 255
 3b0:	23 ed       	ldi	r18, 0xD3	; 211
 3b2:	30 e3       	ldi	r19, 0x30	; 48
 3b4:	91 50       	subi	r25, 0x01	; 1
 3b6:	20 40       	sbci	r18, 0x00	; 0
 3b8:	30 40       	sbci	r19, 0x00	; 0
 3ba:	e1 f7       	brne	.-8      	; 0x3b4 <main+0xa6>
 3bc:	00 c0       	rjmp	.+0      	; 0x3be <main+0xb0>
 3be:	00 00       	nop
	_delay_ms(2000);
	lcd_clear();
 3c0:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
 3c4:	4f ef       	ldi	r20, 0xFF	; 255
 3c6:	89 e6       	ldi	r24, 0x69	; 105
 3c8:	98 e1       	ldi	r25, 0x18	; 24
 3ca:	41 50       	subi	r20, 0x01	; 1
 3cc:	80 40       	sbci	r24, 0x00	; 0
 3ce:	90 40       	sbci	r25, 0x00	; 0
 3d0:	e1 f7       	brne	.-8      	; 0x3ca <main+0xbc>
 3d2:	00 c0       	rjmp	.+0      	; 0x3d4 <main+0xc6>
 3d4:	00 00       	nop
	_delay_ms(1000);
	lcd_goto_xy(0,0);
 3d6:	60 e0       	ldi	r22, 0x00	; 0
 3d8:	80 e0       	ldi	r24, 0x00	; 0
 3da:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
 3de:	c1 2c       	mov	r12, r1
 3e0:	d1 2c       	mov	r13, r1
 3e2:	0c 2d       	mov	r16, r12
 3e4:	1d 2d       	mov	r17, r13
			else
			{
				PORTB |= (1<<PB0);
			}
			
			int is_forward = 1;
 3e6:	ee 24       	eor	r14, r14
 3e8:	e3 94       	inc	r14
 3ea:	f1 2c       	mov	r15, r1
	//int forward =1;
	
	
    while (1) 
    {
		lcd_puts("~ Temperature ~ ");
 3ec:	82 ea       	ldi	r24, 0xA2	; 162
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
		
		Request();		/* send start pulse */
 3f4:	0e 94 59 01 	call	0x2b2	; 0x2b2 <Request>
		Response();		/* receive response */
 3f8:	0e 94 63 01 	call	0x2c6	; 0x2c6 <Response>
		I_RH=Receive_data();	/* store first eight bit in I_RH */
 3fc:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <Receive_data>
 400:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <I_RH>
		D_RH=Receive_data();	/* store next eight bit in D_RH */
 404:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <Receive_data>
 408:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <D_RH>
		I_Temp=Receive_data();	/* store next eight bit in I_Temp */
 40c:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <Receive_data>
 410:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <I_Temp>
		D_Temp=Receive_data();	/* store next eight bit in D_Temp */
 414:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <Receive_data>
 418:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <D_Temp>
		CheckSum=Receive_data();/* store next eight bit in CheckSum */
 41c:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <Receive_data>
 420:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <CheckSum>
		
		if ((I_RH + D_RH + I_Temp + D_Temp) != CheckSum)
 424:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <I_Temp>
 428:	f0 e0       	ldi	r31, 0x00	; 0
 42a:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <I_RH>
 42e:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <D_RH>
 432:	30 e0       	ldi	r19, 0x00	; 0
 434:	29 0f       	add	r18, r25
 436:	31 1d       	adc	r19, r1
 438:	2e 0f       	add	r18, r30
 43a:	3f 1f       	adc	r19, r31
 43c:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <D_Temp>
 440:	29 0f       	add	r18, r25
 442:	31 1d       	adc	r19, r1
 444:	90 e0       	ldi	r25, 0x00	; 0
 446:	28 17       	cp	r18, r24
 448:	39 07       	cpc	r19, r25
 44a:	49 f0       	breq	.+18     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
		{
			lcd_goto_xy(0,0);
 44c:	60 e0       	ldi	r22, 0x00	; 0
 44e:	80 e0       	ldi	r24, 0x00	; 0
 450:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
			lcd_puts("Error");
 454:	83 eb       	ldi	r24, 0xB3	; 179
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
 45c:	ea c0       	rjmp	.+468    	; 0x632 <__LOCK_REGION_LENGTH__+0x232>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 45e:	4a e0       	ldi	r20, 0x0A	; 10
 460:	be 01       	movw	r22, r28
 462:	6f 5f       	subi	r22, 0xFF	; 255
 464:	7f 4f       	sbci	r23, 0xFF	; 255
 466:	cf 01       	movw	r24, r30
 468:	0e 94 2e 03 	call	0x65c	; 0x65c <__itoa_ncheck>
		}
		
		else
		{
			itoa(I_Temp,data,10);
			lcd_goto_xy(5,1);
 46c:	61 e0       	ldi	r22, 0x01	; 1
 46e:	85 e0       	ldi	r24, 0x05	; 5
 470:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
			lcd_puts(data);
 474:	ce 01       	movw	r24, r28
 476:	01 96       	adiw	r24, 0x01	; 1
 478:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
			lcd_puts(".");
 47c:	80 ea       	ldi	r24, 0xA0	; 160
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
 484:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <D_Temp>
 488:	4a e0       	ldi	r20, 0x0A	; 10
 48a:	be 01       	movw	r22, r28
 48c:	6f 5f       	subi	r22, 0xFF	; 255
 48e:	7f 4f       	sbci	r23, 0xFF	; 255
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	0e 94 2e 03 	call	0x65c	; 0x65c <__itoa_ncheck>
			
			itoa(D_Temp,data,10);
			lcd_puts(data);  
 496:	ce 01       	movw	r24, r28
 498:	01 96       	adiw	r24, 0x01	; 1
 49a:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
			lcd_puts("C ");
 49e:	89 eb       	ldi	r24, 0xB9	; 185
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
			
			//DDRB |= (1<<PB1);
			if (I_Temp >= 0b00011110 )
 4a6:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <I_Temp>
 4aa:	8e 31       	cpi	r24, 0x1E	; 30
 4ac:	98 f0       	brcs	.+38     	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
			{
				
				lcd_goto_xy(0,0);
 4ae:	60 e0       	ldi	r22, 0x00	; 0
 4b0:	80 e0       	ldi	r24, 0x00	; 0
 4b2:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
				lcd_puts("COOLING ON   ");
 4b6:	8c eb       	ldi	r24, 0xBC	; 188
 4b8:	90 e0       	ldi	r25, 0x00	; 0
 4ba:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
				//_delay_ms(1000);
				PORTB &= ~(1<<PB1);
 4be:	c1 98       	cbi	0x18, 1	; 24
 4c0:	2f ef       	ldi	r18, 0xFF	; 255
 4c2:	39 e6       	ldi	r19, 0x69	; 105
 4c4:	48 e1       	ldi	r20, 0x18	; 24
 4c6:	21 50       	subi	r18, 0x01	; 1
 4c8:	30 40       	sbci	r19, 0x00	; 0
 4ca:	40 40       	sbci	r20, 0x00	; 0
 4cc:	e1 f7       	brne	.-8      	; 0x4c6 <__LOCK_REGION_LENGTH__+0xc6>
 4ce:	00 c0       	rjmp	.+0      	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
 4d0:	00 00       	nop
 4d2:	0a c0       	rjmp	.+20     	; 0x4e8 <__LOCK_REGION_LENGTH__+0xe8>
				_delay_ms(1000);
				
			}
		
			else{
				PORTB |= (1<<PB1);             
 4d4:	c1 9a       	sbi	0x18, 1	; 24
 4d6:	8f ef       	ldi	r24, 0xFF	; 255
 4d8:	99 e6       	ldi	r25, 0x69	; 105
 4da:	28 e1       	ldi	r18, 0x18	; 24
 4dc:	81 50       	subi	r24, 0x01	; 1
 4de:	90 40       	sbci	r25, 0x00	; 0
 4e0:	20 40       	sbci	r18, 0x00	; 0
 4e2:	e1 f7       	brne	.-8      	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
 4e4:	00 c0       	rjmp	.+0      	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
 4e6:	00 00       	nop
				_delay_ms(1000);
			}
		
			//////////////////////////////////////////////////// Motion Detection with PIR Sensor ///////////////////////////////////////////////////////////////////
			
			if((PINA & (1<<PA0)) || (PIND & (1<<PD0)) )
 4e8:	c8 99       	sbic	0x19, 0	; 25
 4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
 4ec:	80 9b       	sbis	0x10, 0	; 16
 4ee:	0c c0       	rjmp	.+24     	; 0x508 <__LOCK_REGION_LENGTH__+0x108>
			{
				PORTB &= ~(1<<PB0);
 4f0:	c0 98       	cbi	0x18, 0	; 24
 4f2:	3f ef       	ldi	r19, 0xFF	; 255
 4f4:	41 e1       	ldi	r20, 0x11	; 17
 4f6:	8a e7       	ldi	r24, 0x7A	; 122
 4f8:	31 50       	subi	r19, 0x01	; 1
 4fa:	40 40       	sbci	r20, 0x00	; 0
 4fc:	80 40       	sbci	r24, 0x00	; 0
 4fe:	e1 f7       	brne	.-8      	; 0x4f8 <__LOCK_REGION_LENGTH__+0xf8>
 500:	00 c0       	rjmp	.+0      	; 0x502 <__LOCK_REGION_LENGTH__+0x102>
 502:	00 00       	nop
				_delay_ms(5000);
				PORTB |= (1<<PB0);
 504:	c0 9a       	sbi	0x18, 0	; 24
 506:	01 c0       	rjmp	.+2      	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>

			}
			else
			{
				PORTB |= (1<<PB0);
 508:	c0 9a       	sbi	0x18, 0	; 24
			}
			
			int is_forward = 1;
			int delay;
			if(PIND & (1<<PIND3)){//switch                             ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////new///////////////////////////////
 50a:	83 9b       	sbis	0x10, 3	; 16
 50c:	92 c0       	rjmp	.+292    	; 0x632 <__LOCK_REGION_LENGTH__+0x232>
				
				if(PIND & (1 << PIND6)){//direction check
 50e:	86 9b       	sbis	0x10, 6	; 16
 510:	12 c0       	rjmp	.+36     	; 0x536 <__LOCK_REGION_LENGTH__+0x136>
					lcd_init(LCD_BACKLIGHT_ON);
 512:	88 e0       	ldi	r24, 0x08	; 8
 514:	0e 94 da 00 	call	0x1b4	; 0x1b4 <lcd_init>
					lcd_clear();			// Clear LCD
 518:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
					lcd_goto_xy(2,0);		// column and row position
 51c:	60 e0       	ldi	r22, 0x00	; 0
 51e:	82 e0       	ldi	r24, 0x02	; 2
 520:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
					lcd_puts(" TABLE FORWARD");
 524:	8a ec       	ldi	r24, 0xCA	; 202
 526:	90 e0       	ldi	r25, 0x00	; 0
 528:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
					is_forward = 1;
					delay = 1;
 52c:	8e 2d       	mov	r24, r14
 52e:	9f 2d       	mov	r25, r15
				if(PIND & (1 << PIND6)){//direction check
					lcd_init(LCD_BACKLIGHT_ON);
					lcd_clear();			// Clear LCD
					lcd_goto_xy(2,0);		// column and row position
					lcd_puts(" TABLE FORWARD");
					is_forward = 1;
 530:	2e 2d       	mov	r18, r14
 532:	3f 2d       	mov	r19, r15
 534:	18 c0       	rjmp	.+48     	; 0x566 <__LOCK_REGION_LENGTH__+0x166>
					delay = 1;
				}
				else if(PIND & (1 << PIND4)){
 536:	84 9b       	sbis	0x10, 4	; 16
 538:	12 c0       	rjmp	.+36     	; 0x55e <__LOCK_REGION_LENGTH__+0x15e>
					lcd_init(LCD_BACKLIGHT_ON);
 53a:	88 e0       	ldi	r24, 0x08	; 8
 53c:	0e 94 da 00 	call	0x1b4	; 0x1b4 <lcd_init>
					lcd_clear();			// Clear LCD
 540:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
					lcd_goto_xy(2,0);		// column and row position
 544:	60 e0       	ldi	r22, 0x00	; 0
 546:	82 e0       	ldi	r24, 0x02	; 2
 548:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
					lcd_puts(" TABLE BACKWARD");
 54c:	89 ed       	ldi	r24, 0xD9	; 217
 54e:	90 e0       	ldi	r25, 0x00	; 0
 550:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
					is_forward = 0;
					delay = 1;
 554:	8e 2d       	mov	r24, r14
 556:	9f 2d       	mov	r25, r15
				else if(PIND & (1 << PIND4)){
					lcd_init(LCD_BACKLIGHT_ON);
					lcd_clear();			// Clear LCD
					lcd_goto_xy(2,0);		// column and row position
					lcd_puts(" TABLE BACKWARD");
					is_forward = 0;
 558:	2c 2d       	mov	r18, r12
 55a:	3d 2d       	mov	r19, r13
 55c:	04 c0       	rjmp	.+8      	; 0x566 <__LOCK_REGION_LENGTH__+0x166>
 55e:	8c 2d       	mov	r24, r12
 560:	9d 2d       	mov	r25, r13
			else
			{
				PORTB |= (1<<PB0);
			}
			
			int is_forward = 1;
 562:	2e 2d       	mov	r18, r14
 564:	3f 2d       	mov	r19, r15
					is_forward = 0;
					delay = 1;
				}
				
				while(1){
					if(is_forward){//forward
 566:	21 15       	cp	r18, r1
 568:	31 05       	cpc	r19, r1
 56a:	19 f0       	breq	.+6      	; 0x572 <__LOCK_REGION_LENGTH__+0x172>
						PORTC &= ~(1<<PC6);		
 56c:	ae 98       	cbi	0x15, 6	; 21
						PORTC |= 1<<PC7;
 56e:	af 9a       	sbi	0x15, 7	; 21
 570:	02 c0       	rjmp	.+4      	; 0x576 <__LOCK_REGION_LENGTH__+0x176>
					}else if(is_forward == 0){//backward
						PORTC |= (1<<PC6);
 572:	ae 9a       	sbi	0x15, 6	; 21
						PORTC &= ~(1<<PC7);
 574:	af 98       	cbi	0x15, 7	; 21
					}
					if(delay){
 576:	89 2b       	or	r24, r25
 578:	51 f0       	breq	.+20     	; 0x58e <__LOCK_REGION_LENGTH__+0x18e>
 57a:	9f ef       	ldi	r25, 0xFF	; 255
 57c:	49 eb       	ldi	r20, 0xB9	; 185
 57e:	8b ed       	ldi	r24, 0xDB	; 219
 580:	91 50       	subi	r25, 0x01	; 1
 582:	40 40       	sbci	r20, 0x00	; 0
 584:	80 40       	sbci	r24, 0x00	; 0
 586:	e1 f7       	brne	.-8      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
 588:	00 c0       	rjmp	.+0      	; 0x58a <__LOCK_REGION_LENGTH__+0x18a>
 58a:	00 00       	nop
 58c:	09 c0       	rjmp	.+18     	; 0x5a0 <__LOCK_REGION_LENGTH__+0x1a0>
 58e:	9f ef       	ldi	r25, 0xFF	; 255
 590:	49 e6       	ldi	r20, 0x69	; 105
 592:	88 e1       	ldi	r24, 0x18	; 24
 594:	91 50       	subi	r25, 0x01	; 1
 596:	40 40       	sbci	r20, 0x00	; 0
 598:	80 40       	sbci	r24, 0x00	; 0
 59a:	e1 f7       	brne	.-8      	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
 59c:	00 c0       	rjmp	.+0      	; 0x59e <__LOCK_REGION_LENGTH__+0x19e>
 59e:	00 00       	nop
					_delay_ms(9000);
						delay = 0;
					}else
						_delay_ms(1000);
					
					if((PIND & (1 << PIND6)) || (PIND & (1 << PIND4))){
 5a0:	86 99       	sbic	0x10, 6	; 16
 5a2:	04 c0       	rjmp	.+8      	; 0x5ac <__LOCK_REGION_LENGTH__+0x1ac>
 5a4:	80 2f       	mov	r24, r16
 5a6:	91 2f       	mov	r25, r17
 5a8:	84 9b       	sbis	0x10, 4	; 16
 5aa:	dd cf       	rjmp	.-70     	; 0x566 <__LOCK_REGION_LENGTH__+0x166>
						PORTC |= (1<<PC6);
 5ac:	ae 9a       	sbi	0x15, 6	; 21
						PORTC |= (1<<PC7);
 5ae:	af 9a       	sbi	0x15, 7	; 21
						break;
					}
				}
				if(is_forward){
 5b0:	23 2b       	or	r18, r19
 5b2:	09 f1       	breq	.+66     	; 0x5f6 <__LOCK_REGION_LENGTH__+0x1f6>
					lcd_init(LCD_BACKLIGHT_ON);
 5b4:	88 e0       	ldi	r24, 0x08	; 8
 5b6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <lcd_init>
					lcd_clear();			// Clear LCD
 5ba:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
					lcd_goto_xy(2,0);		// column and row position
 5be:	60 e0       	ldi	r22, 0x00	; 0
 5c0:	82 e0       	ldi	r24, 0x02	; 2
 5c2:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
					lcd_puts(" TABLE LAMP ON");
 5c6:	89 ee       	ldi	r24, 0xE9	; 233
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
					PORTB |= 1<<PB6;		// study lamp   PB6 MOTOR on
 5ce:	c6 9a       	sbi	0x18, 6	; 24
					PORTB &= ~(1<<PB5);		// study lamp   PB5 MOTOR off
 5d0:	c5 98       	cbi	0x18, 5	; 24
 5d2:	94 e5       	ldi	r25, 0x54	; 84
 5d4:	27 e9       	ldi	r18, 0x97	; 151
 5d6:	3f eb       	ldi	r19, 0xBF	; 191
 5d8:	41 e0       	ldi	r20, 0x01	; 1
 5da:	91 50       	subi	r25, 0x01	; 1
 5dc:	20 40       	sbci	r18, 0x00	; 0
 5de:	30 40       	sbci	r19, 0x00	; 0
 5e0:	40 40       	sbci	r20, 0x00	; 0
 5e2:	d9 f7       	brne	.-10     	; 0x5da <__LOCK_REGION_LENGTH__+0x1da>
 5e4:	00 c0       	rjmp	.+0      	; 0x5e6 <__LOCK_REGION_LENGTH__+0x1e6>
 5e6:	00 c0       	rjmp	.+0      	; 0x5e8 <__LOCK_REGION_LENGTH__+0x1e8>
 5e8:	00 00       	nop
					_delay_ms(22000);
					
					PORTB &= ~(1<<PB5);
 5ea:	c5 98       	cbi	0x18, 5	; 24
					PORTB &= ~(1<<PB6);
 5ec:	c6 98       	cbi	0x18, 6	; 24
					if(PIND & (1<<PIND1)) // if LDR=1
 5ee:	81 9b       	sbis	0x10, 1	; 16
 5f0:	20 c0       	rjmp	.+64     	; 0x632 <__LOCK_REGION_LENGTH__+0x232>
						PORTB |= 1<<PB7; // study lamp on
 5f2:	c7 9a       	sbi	0x18, 7	; 24
 5f4:	1e c0       	rjmp	.+60     	; 0x632 <__LOCK_REGION_LENGTH__+0x232>
				}else{
					lcd_init(LCD_BACKLIGHT_ON);
 5f6:	88 e0       	ldi	r24, 0x08	; 8
 5f8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <lcd_init>
					lcd_clear();			// Clear LCD
 5fc:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
					lcd_goto_xy(2,0);		// column and row position
 600:	60 e0       	ldi	r22, 0x00	; 0
 602:	82 e0       	ldi	r24, 0x02	; 2
 604:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_goto_xy>
					lcd_puts(" TABLE LAMP OFF");
 608:	88 ef       	ldi	r24, 0xF8	; 248
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	0e 94 3a 01 	call	0x274	; 0x274 <lcd_puts>
					PORTB &= ~(1<<PB7);
 610:	c7 98       	cbi	0x18, 7	; 24
					PORTB &= ~(1<<PB6);		// study lamp   PB6 MOTOR on
 612:	c6 98       	cbi	0x18, 6	; 24
					PORTB |= (1<<PB5);		// study lamp   PB5 MOTOR off
 614:	c5 9a       	sbi	0x18, 5	; 24
 616:	84 e5       	ldi	r24, 0x54	; 84
 618:	97 e9       	ldi	r25, 0x97	; 151
 61a:	2f eb       	ldi	r18, 0xBF	; 191
 61c:	31 e0       	ldi	r19, 0x01	; 1
 61e:	81 50       	subi	r24, 0x01	; 1
 620:	90 40       	sbci	r25, 0x00	; 0
 622:	20 40       	sbci	r18, 0x00	; 0
 624:	30 40       	sbci	r19, 0x00	; 0
 626:	d9 f7       	brne	.-10     	; 0x61e <__LOCK_REGION_LENGTH__+0x21e>
 628:	00 c0       	rjmp	.+0      	; 0x62a <__LOCK_REGION_LENGTH__+0x22a>
 62a:	00 c0       	rjmp	.+0      	; 0x62c <__LOCK_REGION_LENGTH__+0x22c>
 62c:	00 00       	nop
					_delay_ms(22000);
					PORTB &= ~(1<<PB5);
 62e:	c5 98       	cbi	0x18, 5	; 24
					PORTB &= ~(1<<PB6);
 630:	c6 98       	cbi	0x18, 6	; 24
 632:	4f ef       	ldi	r20, 0xFF	; 255
 634:	89 e6       	ldi	r24, 0x69	; 105
 636:	98 e1       	ldi	r25, 0x18	; 24
 638:	41 50       	subi	r20, 0x01	; 1
 63a:	80 40       	sbci	r24, 0x00	; 0
 63c:	90 40       	sbci	r25, 0x00	; 0
 63e:	e1 f7       	brne	.-8      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
 640:	00 c0       	rjmp	.+0      	; 0x642 <__LOCK_REGION_LENGTH__+0x242>
 642:	00 00       	nop
				
			}
		
		}
	_delay_ms(1000);
	lcd_clear();
 644:	0e 94 36 01 	call	0x26c	; 0x26c <lcd_clear>
 648:	2f ef       	ldi	r18, 0xFF	; 255
 64a:	39 e6       	ldi	r19, 0x69	; 105
 64c:	48 e1       	ldi	r20, 0x18	; 24
 64e:	21 50       	subi	r18, 0x01	; 1
 650:	30 40       	sbci	r19, 0x00	; 0
 652:	40 40       	sbci	r20, 0x00	; 0
 654:	e1 f7       	brne	.-8      	; 0x64e <__LOCK_REGION_LENGTH__+0x24e>
 656:	00 c0       	rjmp	.+0      	; 0x658 <__LOCK_REGION_LENGTH__+0x258>
 658:	00 00       	nop
 65a:	c8 ce       	rjmp	.-624    	; 0x3ec <main+0xde>

0000065c <__itoa_ncheck>:
 65c:	bb 27       	eor	r27, r27
 65e:	4a 30       	cpi	r20, 0x0A	; 10
 660:	31 f4       	brne	.+12     	; 0x66e <__itoa_ncheck+0x12>
 662:	99 23       	and	r25, r25
 664:	22 f4       	brpl	.+8      	; 0x66e <__itoa_ncheck+0x12>
 666:	bd e2       	ldi	r27, 0x2D	; 45
 668:	90 95       	com	r25
 66a:	81 95       	neg	r24
 66c:	9f 4f       	sbci	r25, 0xFF	; 255
 66e:	0c 94 3a 03 	jmp	0x674	; 0x674 <__utoa_common>

00000672 <__utoa_ncheck>:
 672:	bb 27       	eor	r27, r27

00000674 <__utoa_common>:
 674:	fb 01       	movw	r30, r22
 676:	55 27       	eor	r21, r21
 678:	aa 27       	eor	r26, r26
 67a:	88 0f       	add	r24, r24
 67c:	99 1f       	adc	r25, r25
 67e:	aa 1f       	adc	r26, r26
 680:	a4 17       	cp	r26, r20
 682:	10 f0       	brcs	.+4      	; 0x688 <__utoa_common+0x14>
 684:	a4 1b       	sub	r26, r20
 686:	83 95       	inc	r24
 688:	50 51       	subi	r21, 0x10	; 16
 68a:	b9 f7       	brne	.-18     	; 0x67a <__utoa_common+0x6>
 68c:	a0 5d       	subi	r26, 0xD0	; 208
 68e:	aa 33       	cpi	r26, 0x3A	; 58
 690:	08 f0       	brcs	.+2      	; 0x694 <__utoa_common+0x20>
 692:	a9 5d       	subi	r26, 0xD9	; 217
 694:	a1 93       	st	Z+, r26
 696:	00 97       	sbiw	r24, 0x00	; 0
 698:	79 f7       	brne	.-34     	; 0x678 <__utoa_common+0x4>
 69a:	b1 11       	cpse	r27, r1
 69c:	b1 93       	st	Z+, r27
 69e:	11 92       	st	Z+, r1
 6a0:	cb 01       	movw	r24, r22
 6a2:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <strrev>

000006a6 <strrev>:
 6a6:	dc 01       	movw	r26, r24
 6a8:	fc 01       	movw	r30, r24
 6aa:	67 2f       	mov	r22, r23
 6ac:	71 91       	ld	r23, Z+
 6ae:	77 23       	and	r23, r23
 6b0:	e1 f7       	brne	.-8      	; 0x6aa <strrev+0x4>
 6b2:	32 97       	sbiw	r30, 0x02	; 2
 6b4:	04 c0       	rjmp	.+8      	; 0x6be <strrev+0x18>
 6b6:	7c 91       	ld	r23, X
 6b8:	6d 93       	st	X+, r22
 6ba:	70 83       	st	Z, r23
 6bc:	62 91       	ld	r22, -Z
 6be:	ae 17       	cp	r26, r30
 6c0:	bf 07       	cpc	r27, r31
 6c2:	c8 f3       	brcs	.-14     	; 0x6b6 <strrev+0x10>
 6c4:	08 95       	ret

000006c6 <_exit>:
 6c6:	f8 94       	cli

000006c8 <__stop_program>:
 6c8:	ff cf       	rjmp	.-2      	; 0x6c8 <__stop_program>
